{"version":3,"file":"chain.js","names":["AE_AMOUNT_FORMATS","formatAmount","isAccountNotFoundError","pause","unwrapProxy","isNameValid","produceNameId","DRY_RUN_ACCOUNT","AensPointerContextError","DryRunError","InvalidAensNameError","TxTimedOutError","TxNotInChainError","InternalError","decode","encode","Encoding","_getPollInterval","type","_expectedMineRate","_microBlockCycle","onNode","_ref","_await$getVal","getVal","t","val","devModeDef","def","getNetworkId","base","Math","floor","heightCache","WeakMap","getHeight","cached","options","cache","get","time","Date","now","height","getCurrentKeyBlockHeight","set","poll","th","blocks","interval","_interval","max","tx","getTransactionByHash","blockHeight","ttl","awaitHeight","_interval2","min","currentHeight","waitForTxConfirm","txHash","confirm","newBlockHeight","getAccount","address","hash","getAccountByPubkeyAndHeight","getAccountByPubkeyAndHash","getAccountByPubkey","getBalance","format","AETTOS","addr","startsWith","AccountAddress","balance","catch","error","targetDenomination","getCurrentGeneration","getGeneration","hashOrHeight","getGenerationByHeight","getGenerationByHash","getMicroBlockTransactions","getMicroBlockTransactionsByHash","transactions","getKeyBlock","getKeyBlockByHeight","getKeyBlockByHash","getMicroBlockHeader","getMicroBlockHeaderByHash","txDryRunRequests","Map","txDryRunHandler","key","rs","delete","dryRunRes","top","protectedDryRunTxs","txEvents","txs","map","req","accounts","Array","from","Set","accountAddress","pubKey","amount","forEach","reject","results","result","reason","resultPayload","idx","resolve","Object","assign","txDryRun","combine","_txDryRunRequests$get","join","requests","Promise","_requests$timeout","push","timeout","setTimeout","getContractByteCode","contractId","getContractCode","getContract","getName","name","getNameEntryByName","resolveName","nameOrId","verify","resolveByNode","pointer","pointers","find","p","id"],"sources":["../src/chain.ts"],"sourcesContent":["import { AE_AMOUNT_FORMATS, formatAmount } from './utils/amount-formatter.js';\nimport { isAccountNotFoundError, pause } from './utils/other.js';\nimport { unwrapProxy } from './utils/wrap-proxy.js';\nimport { isNameValid, produceNameId } from './tx/builder/helpers.js';\nimport { AensName, DRY_RUN_ACCOUNT } from './tx/builder/constants.js';\nimport {\n  AensPointerContextError,\n  DryRunError,\n  InvalidAensNameError,\n  TxTimedOutError,\n  TxNotInChainError,\n  InternalError,\n} from './utils/errors.js';\nimport Node from './Node.js';\nimport { DryRunResult, DryRunResults, SignedTx } from './apis/node/index.js';\nimport { decode, encode, Encoded, Encoding } from './utils/encoder.js';\n\n/**\n * @category chain\n * @param type - Type\n * @param options - Options\n */\nexport async function _getPollInterval(\n  type: 'key-block' | 'micro-block',\n  {\n    _expectedMineRate,\n    _microBlockCycle,\n    onNode,\n  }: { _expectedMineRate?: number; _microBlockCycle?: number; onNode: Node },\n): Promise<number> {\n  const getVal = async (\n    t: string,\n    val: number | undefined,\n    devModeDef: number,\n    def: number,\n  ): Promise<number | null> => {\n    if (t !== type) return null;\n    if (val != null) return val;\n    return (await onNode?.getNetworkId()) === 'ae_dev' ? devModeDef : def;\n  };\n\n  const base =\n    (await getVal('key-block', _expectedMineRate, 0, 180000)) ??\n    (await getVal('micro-block', _microBlockCycle, 0, 3000)) ??\n    (() => {\n      throw new InternalError(`Unknown type: ${type}`);\n    })();\n  return Math.floor(base / 3);\n}\n\nconst heightCache: WeakMap<Node, { time: number; height: number }> = new WeakMap();\n\n/**\n * Obtain current height of the chain\n * @category chain\n * @param options - Options\n * @param options.cached - Get height from the cache. The lag behind the actual height shouldn't\n * be more than 1 block. Use if needed to reduce requests count, and approximate value can be used.\n * For example, for timeout check in transaction status polling.\n * @returns Current chain height\n */\nexport async function getHeight({\n  cached = false,\n  ...options\n}: {\n  onNode: Node;\n  cached?: boolean;\n} & Parameters<typeof _getPollInterval>[1]): Promise<number> {\n  const onNode = unwrapProxy(options.onNode);\n  if (cached) {\n    const cache = heightCache.get(onNode);\n    if (cache != null && cache.time > Date.now() - (await _getPollInterval('key-block', options))) {\n      return cache.height;\n    }\n  }\n  const { height } = await onNode.getCurrentKeyBlockHeight();\n  heightCache.set(onNode, { height, time: Date.now() });\n  return height;\n}\n\n/**\n * Return transaction details if it is mined, fail otherwise.\n * If the transaction has ttl specified then would wait till it leaves the mempool.\n * Otherwise would fail if a specified amount of blocks were mined.\n * @category chain\n * @param th - The hash of transaction to poll\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.blocks - Number of blocks mined after which to fail if transaction ttl is not set\n * @param options.onNode - Node to use\n * @returns The transaction as it was mined\n */\nexport async function poll(\n  th: Encoded.TxHash,\n  {\n    blocks = 5,\n    interval,\n    ...options\n  }: { blocks?: number; interval?: number; onNode: Node } & Parameters<typeof _getPollInterval>[1],\n): ReturnType<Node['getTransactionByHash']> {\n  interval ??= await _getPollInterval('micro-block', options);\n  let max;\n  do {\n    const tx = await options.onNode.getTransactionByHash(th);\n    if (tx.blockHeight !== -1) return tx;\n    if (max == null) {\n      max = tx.tx.ttl !== 0 ? -1 : (await getHeight({ ...options, cached: true })) + blocks;\n    }\n    await pause(interval);\n  } while (max === -1 ? true : (await getHeight({ ...options, cached: true })) < max);\n  throw new TxTimedOutError(blocks, th);\n}\n\n/**\n * Wait for the chain to reach a specific height\n * @category chain\n * @param height - Height to wait for\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.onNode - Node to use\n * @returns Current chain height\n */\nexport async function awaitHeight(\n  height: number,\n  {\n    interval,\n    ...options\n  }: { interval?: number; onNode: Node } & Parameters<typeof _getPollInterval>[1],\n): Promise<number> {\n  interval ??= Math.min(await _getPollInterval('key-block', options), 5000);\n  let currentHeight;\n  do {\n    if (currentHeight != null) await pause(interval);\n    currentHeight = await getHeight(options);\n  } while (currentHeight < height);\n  return currentHeight;\n}\n\n/**\n * Wait for transaction confirmation\n * @category chain\n * @param txHash - Transaction hash\n * @param options - Options\n * @param options.confirm - Number of micro blocks to wait for transaction confirmation\n * @param options.onNode - Node to use\n * @returns Current Height\n */\nexport async function waitForTxConfirm(\n  txHash: Encoded.TxHash,\n  {\n    confirm = 3,\n    onNode,\n    ...options\n  }: { confirm?: number; onNode: Node } & Parameters<typeof awaitHeight>[1],\n): Promise<number> {\n  const { blockHeight } = await onNode.getTransactionByHash(txHash);\n  const height = await awaitHeight(blockHeight + confirm, { onNode, ...options });\n  const { blockHeight: newBlockHeight } = await onNode.getTransactionByHash(txHash);\n  switch (newBlockHeight) {\n    case -1:\n      throw new TxNotInChainError(txHash);\n    case blockHeight:\n      return height;\n    default:\n      return waitForTxConfirm(txHash, { onNode, confirm, ...options });\n  }\n}\n\n/**\n * Get account by account public key\n * @category chain\n * @param address - Account address (public key)\n * @param options - Options\n * @param options.height - Get account on specific block by block height\n * @param options.hash - Get account on specific block by micro block hash or key block hash\n * @param options.onNode - Node to use\n */\nexport async function getAccount(\n  address: Encoded.AccountAddress | Encoded.ContractAddress,\n  {\n    height,\n    hash,\n    onNode,\n  }: { height?: number; hash?: Encoded.KeyBlockHash | Encoded.MicroBlockHash; onNode: Node },\n): ReturnType<Node['getAccountByPubkey']> {\n  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);\n  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);\n  return onNode.getAccountByPubkey(address);\n}\n\n/**\n * Request the balance of specified account\n * @category chain\n * @param address - The public account address to obtain the balance for\n * @param options - Options\n * @param options.format\n * @param options.height - The chain height at which to obtain the balance for\n * (default: top of chain)\n * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)\n */\nexport async function getBalance(\n  address: Encoded.AccountAddress | Encoded.ContractAddress | Encoded.OracleAddress,\n  {\n    format = AE_AMOUNT_FORMATS.AETTOS,\n    ...options\n  }: { format?: AE_AMOUNT_FORMATS } & Parameters<typeof getAccount>[1],\n): Promise<string> {\n  const addr = address.startsWith('ok_')\n    ? encode(decode(address), Encoding.AccountAddress)\n    : (address as Encoded.AccountAddress | Encoded.ContractAddress);\n\n  const { balance } = await getAccount(addr, options).catch((error) => {\n    if (!isAccountNotFoundError(error)) throw error;\n    return { balance: 0n };\n  });\n\n  return formatAmount(balance, { targetDenomination: format });\n}\n\n/**\n * Obtain current generation\n * @category chain\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Current Generation\n */\nexport async function getCurrentGeneration({\n  onNode,\n}: {\n  onNode: Node;\n}): ReturnType<Node['getCurrentGeneration']> {\n  return onNode.getCurrentGeneration();\n}\n\n/**\n * Get generation by hash or height\n * @category chain\n * @param hashOrHeight - Generation hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Generation\n */\nexport async function getGeneration(\n  hashOrHeight: Encoded.KeyBlockHash | number,\n  { onNode }: { onNode: Node },\n): ReturnType<Node['getGenerationByHash']> {\n  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);\n  return onNode.getGenerationByHash(hashOrHeight);\n}\n\n/**\n * Get micro block transactions\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Transactions\n */\nexport async function getMicroBlockTransactions(\n  hash: Encoded.MicroBlockHash,\n  { onNode }: { onNode: Node },\n): Promise<SignedTx[]> {\n  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;\n}\n\n/**\n * Get key block\n * @category chain\n * @param hashOrHeight - Key block hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Key Block\n */\nexport async function getKeyBlock(\n  hashOrHeight: Encoded.KeyBlockHash | number,\n  { onNode }: { onNode: Node },\n): ReturnType<Node['getKeyBlockByHash']> {\n  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);\n  return onNode.getKeyBlockByHash(hashOrHeight);\n}\n\n/**\n * Get micro block header\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Micro block header\n */\nexport async function getMicroBlockHeader(\n  hash: Encoded.MicroBlockHash,\n  { onNode }: { onNode: Node },\n): ReturnType<Node['getMicroBlockHeaderByHash']> {\n  return onNode.getMicroBlockHeaderByHash(hash);\n}\n\ninterface TxDryRunArguments {\n  tx: Encoded.Transaction;\n  accountAddress: Encoded.AccountAddress;\n  top?: number | Encoded.KeyBlockHash | Encoded.MicroBlockHash;\n  txEvents?: any;\n  resolve: Function;\n  reject: Function;\n}\nconst txDryRunRequests: Map<string, TxDryRunArguments[] & { timeout?: NodeJS.Timeout }> = new Map();\n\nasync function txDryRunHandler(key: string, onNode: Node): Promise<void> {\n  const rs = txDryRunRequests.get(key);\n  txDryRunRequests.delete(key);\n  if (rs == null) throw new InternalError(\"Can't get dry-run request\");\n\n  let dryRunRes;\n  try {\n    const top =\n      typeof rs[0].top === 'number' ? (await getKeyBlock(rs[0].top, { onNode })).hash : rs[0].top;\n    dryRunRes = await onNode.protectedDryRunTxs({\n      top,\n      txEvents: rs[0].txEvents,\n      txs: rs.map((req) => ({ tx: req.tx })),\n      accounts: Array.from(new Set(rs.map((req) => req.accountAddress))).map((pubKey) => ({\n        pubKey,\n        amount: DRY_RUN_ACCOUNT.amount,\n      })),\n    });\n  } catch (error) {\n    rs.forEach(({ reject }) => reject(error));\n    return;\n  }\n\n  const { results, txEvents } = dryRunRes;\n  results.forEach(({ result, reason, ...resultPayload }, idx) => {\n    const { resolve, reject, tx, accountAddress } = rs[idx];\n    if (result === 'ok') resolve({ ...resultPayload, txEvents });\n    else reject(Object.assign(new DryRunError(reason as string), { tx, accountAddress }));\n  });\n}\n\n/**\n * Transaction dry-run\n * @category chain\n * @param tx - transaction to execute\n * @param accountAddress - address that will be used to execute transaction\n * @param options - Options\n * @param options.top - hash of block on which to make dry-run\n * @param options.txEvents - collect and return on-chain tx events that would result from the call\n * @param options.combine - Enables combining of similar requests to a single dry-run call\n * @param options.onNode - Node to use\n */\nexport async function txDryRun(\n  tx: Encoded.Transaction,\n  accountAddress: Encoded.AccountAddress,\n  {\n    top,\n    txEvents,\n    combine,\n    onNode,\n  }: { top?: TxDryRunArguments['top']; txEvents?: boolean; combine?: boolean; onNode: Node },\n): Promise<{ txEvents?: DryRunResults['txEvents'] } & DryRunResult> {\n  const key = combine === true ? [top, txEvents].join() : 'immediate';\n  const requests = txDryRunRequests.get(key) ?? [];\n  txDryRunRequests.set(key, requests);\n  return new Promise((resolve, reject) => {\n    requests.push({\n      tx,\n      accountAddress,\n      top,\n      txEvents,\n      resolve,\n      reject,\n    });\n    if (combine !== true) {\n      void txDryRunHandler(key, onNode);\n      return;\n    }\n    requests.timeout ??= setTimeout(() => {\n      void txDryRunHandler(key, onNode);\n    });\n  });\n}\n\n/**\n * Get contract byte code\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContractByteCode(\n  contractId: Encoded.ContractAddress,\n  { onNode }: { onNode: Node },\n): ReturnType<Node['getContractCode']> {\n  return onNode.getContractCode(contractId);\n}\n\n/**\n * Get contract entry\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContract(\n  contractId: Encoded.ContractAddress,\n  { onNode }: { onNode: Node },\n): ReturnType<Node['getContract']> {\n  return onNode.getContract(contractId);\n}\n\n/**\n * Get name entry\n * @category AENS\n * @param name - AENS name\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getName(\n  name: AensName,\n  { onNode }: { onNode: Node },\n): ReturnType<Node['getNameEntryByName']> {\n  return onNode.getNameEntryByName(name);\n}\n\n/**\n * Resolve AENS name and return name hash\n * @category AENS\n * @param nameOrId - AENS name or address\n * @param key - in AENS pointers record\n * @param options - Options\n * @param options.verify - To ensure that name exist and have a corresponding pointer\n * // TODO: avoid that to don't trust to current api gateway\n * @param options.resolveByNode - Enables pointer resolving using node\n * @param options.onNode - Node to use\n * @returns Address or AENS name hash\n */\nexport async function resolveName<Type extends Encoding.AccountAddress | Encoding.ContractAddress>(\n  nameOrId: AensName | Encoded.Generic<Type>,\n  key: string,\n  {\n    verify = true,\n    resolveByNode = false,\n    onNode,\n  }: { verify?: boolean; resolveByNode?: boolean; onNode: Node },\n): Promise<Encoded.Generic<Type | Encoding.Name>> {\n  if (isNameValid(nameOrId)) {\n    if (verify || resolveByNode) {\n      const name = await onNode.getNameEntryByName(nameOrId);\n      const pointer = name.pointers.find((p) => p.key === key);\n      if (pointer == null) throw new AensPointerContextError(nameOrId, key);\n      if (resolveByNode) return pointer.id as Encoded.Generic<Type>;\n    }\n    return produceNameId(nameOrId);\n  }\n  try {\n    decode(nameOrId);\n    return nameOrId;\n  } catch (error) {\n    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);\n  }\n}\n"],"mappings":"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","ignoreList":[]}
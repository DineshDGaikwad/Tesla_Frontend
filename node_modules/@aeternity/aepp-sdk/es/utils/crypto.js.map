{"version":3,"file":"crypto.js","names":["nacl","blake2b","encode","varuintEncode","concatBuffers","isItemOfArray","decode","Encoding","ArgumentError","isAddressValid","maybeEncoded","encodings","length","AccountAddress","encoding","split","join","error","genSalt","random","BigUint64Array","randomBytes","buffer","Number","BigInt","MAX_SAFE_INTEGER","encodeUnsigned","value","binary","_Buffer","allocUnsafe","writeUInt32BE","slice","findIndex","i","hash","input","from","undefined","encodeContractAddress","owner","nonce","publicKey","ContractAddress","verify","data","signature","address","sign","detached","messagePrefix","messagePrefixLength","messageToHash","message","msg","verifyMessage"],"sources":["../../src/utils/crypto.ts"],"sourcesContent":["import nacl from 'tweetnacl';\n// js extension is required for mjs build, not importing the whole package to reduce bundle size\n// eslint-disable-next-line import/extensions\nimport { blake2b } from 'blakejs/blake2b.js';\nimport { encode as varuintEncode } from 'varuint-bitcoin';\n\nimport { concatBuffers, isItemOfArray } from './other.js';\nimport { decode, encode, Encoded, Encoding } from './encoder.js';\nimport { ArgumentError } from './errors.js';\n\n/**\n * Check if address is valid\n * @param maybeAddress - Address to check\n */\nexport function isAddressValid(maybeAddress: string): maybeAddress is Encoded.AccountAddress;\n/**\n * Check if data is encoded in one of provided encodings\n * @param maybeEncoded - Data to check\n * @param encodings - Rest parameters with encodings to check against\n */\nexport function isAddressValid<E extends Encoding>(\n  maybeEncoded: string,\n  ...encodings: E[]\n): maybeEncoded is Encoded.Generic<E>;\nexport function isAddressValid(maybeEncoded: string, ...encodings: Encoding[]): boolean {\n  if (encodings.length === 0) encodings = [Encoding.AccountAddress];\n  try {\n    decode(maybeEncoded as Encoded.Any);\n    const encoding = maybeEncoded.split('_')[0];\n    if (!isItemOfArray(encoding, encodings)) {\n      throw new ArgumentError(\n        'Encoded string type',\n        encodings.length > 1 ? `one of ${encodings.join(', ')}` : encodings[0],\n        encoding,\n      );\n    }\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Generate a random salt (positive integer)\n * @returns random salt\n */\nexport function genSalt(): number {\n  const [random] = new BigUint64Array(nacl.randomBytes(8).buffer);\n  return Number(random % BigInt(Number.MAX_SAFE_INTEGER));\n}\n\n/**\n * Converts a positive integer to the smallest possible\n * representation in a binary digit representation\n * @param value - Value to encode\n * @returns Encoded number\n */\nexport function encodeUnsigned(value: number): Buffer {\n  const binary = Buffer.allocUnsafe(4);\n  binary.writeUInt32BE(value);\n  return binary.slice(binary.findIndex((i) => i !== 0));\n}\n\n/**\n * Calculate 256bits Blake2b hash of `input`\n * @param input - Data to hash\n * @returns Hash\n */\nexport function hash(input: string | Uint8Array): Buffer {\n  return Buffer.from(blake2b(input, undefined, 32)); // 256 bits\n}\n\n// Todo Duplicated in tx builder. remove\n/**\n * Compute contract address\n * @category contract\n * @param owner - Address of contract owner\n * @param nonce - Round when contract was created\n * @returns Contract address\n */\nexport function encodeContractAddress(\n  owner: Encoded.AccountAddress,\n  nonce: number,\n): Encoded.ContractAddress {\n  const publicKey = decode(owner);\n  const binary = concatBuffers([publicKey, encodeUnsigned(nonce)]);\n  return encode(hash(binary), Encoding.ContractAddress);\n}\n\n/**\n * Verify that signature was signed by public key\n * @param data - Data that was signed\n * @param signature - Signature of data\n * @param address - Address to verify against\n * @returns is data was signed by address\n */\nexport function verify(\n  data: Uint8Array,\n  signature: Uint8Array,\n  address: Encoded.AccountAddress,\n): boolean {\n  return nacl.sign.detached.verify(data, signature, decode(address));\n}\n\nconst messagePrefix = Buffer.from('aeternity Signed Message:\\n', 'utf8');\nexport const messagePrefixLength = varuintEncode(messagePrefix.length).buffer;\n\n// TODO: consider rename to hashMessage\nexport function messageToHash(message: string): Buffer {\n  const msg = Buffer.from(message, 'utf8');\n  return hash(\n    concatBuffers([messagePrefixLength, messagePrefix, varuintEncode(msg.length).buffer, msg]),\n  );\n}\n\n/**\n * Verify that message was signed by address\n * @param message - Message that was signed\n * @param signature - Signature of message\n * @param address - Address to verify against\n * @returns is data was signed by address\n */\n// TODO: deprecate in favour of `verify(messageToHash(message), ...`, also the name is confusing\n// it should contain \"signature\"\nexport function verifyMessage(\n  message: string,\n  signature: Uint8Array,\n  address: Encoded.AccountAddress,\n): boolean {\n  return verify(messageToHash(message), signature, address);\n}\n"],"mappings":"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","ignoreList":[]}
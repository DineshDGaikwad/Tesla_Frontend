import { decode as rlpDecode, encode as rlpEncode } from 'rlp';
import { ArgumentError, DecodeError, SchemaNotFoundError, InternalError } from '../../utils/errors.js';
import { encode, decode } from '../../utils/encoder.js';
import { readInt } from './helpers.js';
export function getSchema(schemas, Tag, tag, version) {
  const subSchemas = schemas.filter(s => s.tag.constValue === tag);
  if (subSchemas.length === 0) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, 0);
  if (version == null) {
    const defaultSchema = subSchemas.find(schema => schema.version.constValueOptional);
    if (defaultSchema == null) throw new InternalError(`Can't find default schema of ${Tag[tag]} (${tag})`);
    version = defaultSchema.version.constValue;
  }
  const schema = subSchemas.find(s => s.version.constValue === version);
  if (schema == null) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, version);
  return Object.entries(schema);
}
export function packRecord(schemas, Tag, params, extraParams, encoding) {
  const schema = getSchema(schemas, Tag, params.tag, params.version);
  const binary = schema.map(([key, field]) => field.serialize(params[key], {
    ...params,
    ...extraParams
  }, params));
  return encode(rlpEncode(binary), encoding);
}
export function unpackRecord(schemas, Tag, encodedRecord, expectedTag, extraParams) {
  const binary = rlpDecode(decode(encodedRecord));
  const tag = +readInt(binary[0]);
  const version = +readInt(binary[1]);
  const schema = getSchema(schemas, Tag, tag, version);
  if (expectedTag != null && expectedTag !== tag) {
    throw new DecodeError(`Expected ${Tag[expectedTag]} tag, got ${Tag[tag]} instead`);
  }
  if (binary.length !== schema.length) {
    throw new ArgumentError('RLP length', schema.length, binary.length);
  }
  return Object.fromEntries(schema.map(([name, field], index) => [name, field.deserialize(binary[index], extraParams)]));
}
//# sourceMappingURL=common.js.map
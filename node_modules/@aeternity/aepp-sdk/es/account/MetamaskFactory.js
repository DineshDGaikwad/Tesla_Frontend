function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { InternalError, UnsupportedPlatformError, UnsupportedVersionError } from '../utils/errors.js';
import semverSatisfies from '../utils/semver-satisfies.js';
import AccountBaseFactory from './BaseFactory.js';
import AccountMetamask, { invokeSnap, snapId } from './Metamask.js';
const snapMinVersion = '0.0.9';
const snapMaxVersion = '0.1.0';
var _AccountMetamaskFactory_brand = /*#__PURE__*/new WeakSet();
var _ensureReadyPromise = /*#__PURE__*/new WeakMap();
/**
 * A factory class that generates instances of AccountMetamask.
 */
export default class AccountMetamaskFactory extends AccountBaseFactory {
  /**
   * @param provider - Connection to MetaMask to use
   */
  constructor(provider) {
    super();
    /**
     * It throws an exception if MetaMask has an incompatible version.
     */
    _classPrivateMethodInitSpec(this, _AccountMetamaskFactory_brand);
    _classPrivateFieldInitSpec(this, _ensureReadyPromise, void 0);
    if (provider != null) {
      this.provider = provider;
      return;
    }
    if (window == null) {
      throw new UnsupportedPlatformError('Window object not found, you can run AccountMetamaskFactory only in browser or setup a provider');
    }
    if (!('ethereum' in window) || window.ethereum == null) {
      throw new UnsupportedPlatformError('`ethereum` object not found, you can run AccountMetamaskFactory only with Metamask enabled or setup a provider');
    }
    this.provider = window.ethereum;
  }
  /**
   * Request MetaMask to install Aeternity snap.
   */
  async installSnap() {
    await _assertClassBrand(_AccountMetamaskFactory_brand, this, _ensureMetamaskSupported).call(this);
    const details = await this.provider.request({
      method: 'wallet_requestSnaps',
      params: {
        [snapId]: {
          version: snapMinVersion
        }
      }
    });
    _classPrivateFieldSet(_ensureReadyPromise, this, Promise.resolve());
    return details[snapId];
  }

  /**
   * It throws an exception if MetaMask or Aeternity snap has an incompatible version or is not
   * installed.
   */
  async ensureReady() {
    const snapVersion = await this.getSnapVersion();
    const args = [snapVersion, snapMinVersion, snapMaxVersion];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError('Aeternity snap in MetaMask', ...args);
    _classPrivateFieldSet(_ensureReadyPromise, this, Promise.resolve());
  }
  /**
   * @returns the version of snap installed in MetaMask
   */
  async getSnapVersion() {
    await _assertClassBrand(_AccountMetamaskFactory_brand, this, _ensureMetamaskSupported).call(this);
    const snaps = await this.provider.request({
      method: 'wallet_getSnaps'
    });
    const version = snaps[snapId]?.version;
    if (version == null) throw new UnsupportedPlatformError('Aeternity snap is not installed to MetaMask');
    return version;
  }

  /**
   * Get an instance of AccountMetaMask for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    await _assertClassBrand(_AccountMetamaskFactory_brand, this, _ensureReady).call(this);
    const address = await invokeSnap(this.provider, 'getPublicKey', {
      derivationPath: [`${accountIndex}'`, "0'", "0'"]
    }, 'publicKey');
    return new AccountMetamask(this.provider, accountIndex, address);
  }
}
async function _ensureMetamaskSupported() {
  const version = await this.provider.request({
    method: 'web3_clientVersion'
  });
  if (version == null) throw new InternalError("Can't get Ethereum Provider version");
  const metamaskPrefix = 'MetaMask/v';
  if (!version.startsWith(metamaskPrefix)) {
    throw new UnsupportedPlatformError(`Expected Metamask, got ${version} instead`);
  }
  const args = [version.slice(metamaskPrefix.length), '12.2.4'];
  if (!semverSatisfies(...args)) throw new UnsupportedVersionError('Metamask', ...args);
}
async function _ensureReady() {
  var _classPrivateFieldGet2;
  (_classPrivateFieldGet2 = _classPrivateFieldGet(_ensureReadyPromise, this)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(_ensureReadyPromise, this, this.ensureReady());
  return _classPrivateFieldGet(_ensureReadyPromise, this);
}
//# sourceMappingURL=MetamaskFactory.js.map
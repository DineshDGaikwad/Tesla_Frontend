import { Buffer as _Buffer } from "buffer";
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { mnemonicToSeed } from '@scure/bip39';
import tweetnaclAuth from 'tweetnacl-auth';
import AccountBaseFactory from './BaseFactory.js';
import AccountMemory from './Memory.js';
import { encode, Encoding, decode } from '../utils/encoder.js';
import { concatBuffers } from '../utils/other.js';
import { InternalError } from '../utils/errors.js';
export const ED25519_CURVE = _Buffer.from('ed25519 seed');
const HARDENED_OFFSET = 0x80000000;
export function deriveKey(message, key) {
  const I = tweetnaclAuth.full(message, key);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}
export function derivePathFromKey(key, segments) {
  return segments.reduce(({
    secretKey,
    chainCode
  }, segment) => {
    const indexBuffer = _Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(segment + HARDENED_OFFSET, 0);
    const data = concatBuffers([_Buffer.alloc(1, 0), secretKey, indexBuffer]);
    return deriveKey(data, chainCode);
  }, key);
}
var _mnemonic = /*#__PURE__*/new WeakMap();
var _wallet = /*#__PURE__*/new WeakMap();
var _AccountMnemonicFactory_brand = /*#__PURE__*/new WeakSet();
/**
 * A factory class that generates instances of AccountMemory based on provided mnemonic phrase.
 */
export default class AccountMnemonicFactory extends AccountBaseFactory {
  /**
   * @param mnemonicOrWallet - BIP39-compatible mnemonic phrase or a wallet derived from mnemonic
   */
  constructor(mnemonicOrWallet) {
    super();
    _classPrivateMethodInitSpec(this, _AccountMnemonicFactory_brand);
    _classPrivateFieldInitSpec(this, _mnemonic, void 0);
    _classPrivateFieldInitSpec(this, _wallet, void 0);
    if (typeof mnemonicOrWallet === 'string') _classPrivateFieldSet(_mnemonic, this, mnemonicOrWallet);else _classPrivateFieldSet(_wallet, this, mnemonicOrWallet);
  }

  /**
   * Get a wallet to initialize AccountMnemonicFactory instead mnemonic phrase.
   * In comparison with mnemonic, the wallet can be used to derive aeternity accounts only.
   */
  async getWallet() {
    if (_classPrivateFieldGet(_wallet, this) != null) return _classPrivateFieldGet(_wallet, this);
    if (_classPrivateFieldGet(_mnemonic, this) == null) throw new InternalError('AccountMnemonicFactory should be initialized with mnemonic or wallet');
    const seed = await mnemonicToSeed(_classPrivateFieldGet(_mnemonic, this));
    const masterKey = deriveKey(seed, ED25519_CURVE);
    const walletKey = derivePathFromKey(masterKey, [44, 457]);
    _classPrivateFieldSet(_wallet, this, {
      secretKey: encode(walletKey.secretKey, Encoding.Bytearray),
      chainCode: encode(walletKey.chainCode, Encoding.Bytearray)
    });
    return _classPrivateFieldGet(_wallet, this);
  }
  /**
   * Get an instance of AccountMemory for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    return new AccountMemory(await _assertClassBrand(_AccountMnemonicFactory_brand, this, _getAccountSecretKey).call(this, accountIndex));
  }
}
async function _getAccountSecretKey(accountIndex) {
  const wallet = await this.getWallet();
  const walletKey = {
    secretKey: decode(wallet.secretKey),
    chainCode: decode(wallet.chainCode)
  };
  const raw = derivePathFromKey(walletKey, [accountIndex, 0, 0]).secretKey;
  return encode(raw, Encoding.AccountSecretKey);
}
//# sourceMappingURL=MnemonicFactory.js.map
import $detectbrowser from "detect-browser";
const { detect } = $detectbrowser;
import $extensionportstream from "extension-port-stream";
const { PortDuplexStream: PortStream } = $extensionportstream;
import config from "./external-extension-config.json" assert { type: "json" };
import { MetaMaskInpageProviderStreamName } from "../MetaMaskInpageProvider.mjs";
import { StreamProvider } from "../StreamProvider.mjs";
import { getDefaultExternalMiddleware } from "../utils.mjs";
const browser = detect();
/**
 * Creates an external extension provider for the given extension type or ID.
 *
 * @param typeOrId - The extension type or ID.
 * @returns The external extension provider.
 */
export function createExternalExtensionProvider(typeOrId = 'stable') {
    let provider;
    try {
        const extensionId = getExtensionId(typeOrId);
        const metamaskPort = chrome.runtime.connect(extensionId);
        const pluginStream = new PortStream(metamaskPort);
        provider = new StreamProvider(pluginStream, {
            jsonRpcStreamName: MetaMaskInpageProviderStreamName,
            logger: console,
            rpcMiddleware: getDefaultExternalMiddleware(console),
        });
        // This is asynchronous but merely logs an error and does not throw upon
        // failure. Previously this just happened as a side-effect in the
        // constructor.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        provider.initialize();
    }
    catch (error) {
        console.dir(`MetaMask connect error.`, error);
        throw error;
    }
    return provider;
}
/**
 * Gets the extension ID for the given extension type or ID.
 *
 * @param typeOrId - The extension type or ID.
 * @returns The extension ID.
 */
function getExtensionId(typeOrId) {
    const ids = browser?.name === 'firefox' ? config.firefoxIds : config.chromeIds;
    return ids[typeOrId] ?? typeOrId;
}
//# sourceMappingURL=createExternalExtensionProvider.mjs.map